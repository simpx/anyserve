// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: grpc_predict_v2.proto
#ifndef GRPC_grpc_5fpredict_5fv2_2eproto__INCLUDED
#define GRPC_grpc_5fpredict_5fv2_2eproto__INCLUDED

#include "grpc_predict_v2.pb.h"

#include <functional>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/client_context.h>
#include <grpcpp/completion_queue.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/proto_utils.h>
#include <grpcpp/impl/rpc_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/support/status.h>
#include <grpcpp/support/stub_options.h>
#include <grpcpp/support/sync_stream.h>

namespace inference {

class GRPCInferenceService final {
 public:
  static constexpr char const* service_full_name() {
    return "inference.GRPCInferenceService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status ServerLive(::grpc::ClientContext* context, const ::inference::ServerLiveRequest& request, ::inference::ServerLiveResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::inference::ServerLiveResponse>> AsyncServerLive(::grpc::ClientContext* context, const ::inference::ServerLiveRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::inference::ServerLiveResponse>>(AsyncServerLiveRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::inference::ServerLiveResponse>> PrepareAsyncServerLive(::grpc::ClientContext* context, const ::inference::ServerLiveRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::inference::ServerLiveResponse>>(PrepareAsyncServerLiveRaw(context, request, cq));
    }
    virtual ::grpc::Status ServerReady(::grpc::ClientContext* context, const ::inference::ServerReadyRequest& request, ::inference::ServerReadyResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::inference::ServerReadyResponse>> AsyncServerReady(::grpc::ClientContext* context, const ::inference::ServerReadyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::inference::ServerReadyResponse>>(AsyncServerReadyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::inference::ServerReadyResponse>> PrepareAsyncServerReady(::grpc::ClientContext* context, const ::inference::ServerReadyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::inference::ServerReadyResponse>>(PrepareAsyncServerReadyRaw(context, request, cq));
    }
    virtual ::grpc::Status ModelReady(::grpc::ClientContext* context, const ::inference::ModelReadyRequest& request, ::inference::ModelReadyResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::inference::ModelReadyResponse>> AsyncModelReady(::grpc::ClientContext* context, const ::inference::ModelReadyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::inference::ModelReadyResponse>>(AsyncModelReadyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::inference::ModelReadyResponse>> PrepareAsyncModelReady(::grpc::ClientContext* context, const ::inference::ModelReadyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::inference::ModelReadyResponse>>(PrepareAsyncModelReadyRaw(context, request, cq));
    }
    virtual ::grpc::Status ServerMetadata(::grpc::ClientContext* context, const ::inference::ServerMetadataRequest& request, ::inference::ServerMetadataResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::inference::ServerMetadataResponse>> AsyncServerMetadata(::grpc::ClientContext* context, const ::inference::ServerMetadataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::inference::ServerMetadataResponse>>(AsyncServerMetadataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::inference::ServerMetadataResponse>> PrepareAsyncServerMetadata(::grpc::ClientContext* context, const ::inference::ServerMetadataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::inference::ServerMetadataResponse>>(PrepareAsyncServerMetadataRaw(context, request, cq));
    }
    virtual ::grpc::Status ModelMetadata(::grpc::ClientContext* context, const ::inference::ModelMetadataRequest& request, ::inference::ModelMetadataResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::inference::ModelMetadataResponse>> AsyncModelMetadata(::grpc::ClientContext* context, const ::inference::ModelMetadataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::inference::ModelMetadataResponse>>(AsyncModelMetadataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::inference::ModelMetadataResponse>> PrepareAsyncModelMetadata(::grpc::ClientContext* context, const ::inference::ModelMetadataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::inference::ModelMetadataResponse>>(PrepareAsyncModelMetadataRaw(context, request, cq));
    }
    virtual ::grpc::Status ModelInfer(::grpc::ClientContext* context, const ::inference::ModelInferRequest& request, ::inference::ModelInferResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::inference::ModelInferResponse>> AsyncModelInfer(::grpc::ClientContext* context, const ::inference::ModelInferRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::inference::ModelInferResponse>>(AsyncModelInferRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::inference::ModelInferResponse>> PrepareAsyncModelInfer(::grpc::ClientContext* context, const ::inference::ModelInferRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::inference::ModelInferResponse>>(PrepareAsyncModelInferRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void ServerLive(::grpc::ClientContext* context, const ::inference::ServerLiveRequest* request, ::inference::ServerLiveResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ServerLive(::grpc::ClientContext* context, const ::inference::ServerLiveRequest* request, ::inference::ServerLiveResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void ServerReady(::grpc::ClientContext* context, const ::inference::ServerReadyRequest* request, ::inference::ServerReadyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ServerReady(::grpc::ClientContext* context, const ::inference::ServerReadyRequest* request, ::inference::ServerReadyResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void ModelReady(::grpc::ClientContext* context, const ::inference::ModelReadyRequest* request, ::inference::ModelReadyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ModelReady(::grpc::ClientContext* context, const ::inference::ModelReadyRequest* request, ::inference::ModelReadyResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void ServerMetadata(::grpc::ClientContext* context, const ::inference::ServerMetadataRequest* request, ::inference::ServerMetadataResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ServerMetadata(::grpc::ClientContext* context, const ::inference::ServerMetadataRequest* request, ::inference::ServerMetadataResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void ModelMetadata(::grpc::ClientContext* context, const ::inference::ModelMetadataRequest* request, ::inference::ModelMetadataResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ModelMetadata(::grpc::ClientContext* context, const ::inference::ModelMetadataRequest* request, ::inference::ModelMetadataResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void ModelInfer(::grpc::ClientContext* context, const ::inference::ModelInferRequest* request, ::inference::ModelInferResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ModelInfer(::grpc::ClientContext* context, const ::inference::ModelInferRequest* request, ::inference::ModelInferResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::inference::ServerLiveResponse>* AsyncServerLiveRaw(::grpc::ClientContext* context, const ::inference::ServerLiveRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::inference::ServerLiveResponse>* PrepareAsyncServerLiveRaw(::grpc::ClientContext* context, const ::inference::ServerLiveRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::inference::ServerReadyResponse>* AsyncServerReadyRaw(::grpc::ClientContext* context, const ::inference::ServerReadyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::inference::ServerReadyResponse>* PrepareAsyncServerReadyRaw(::grpc::ClientContext* context, const ::inference::ServerReadyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::inference::ModelReadyResponse>* AsyncModelReadyRaw(::grpc::ClientContext* context, const ::inference::ModelReadyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::inference::ModelReadyResponse>* PrepareAsyncModelReadyRaw(::grpc::ClientContext* context, const ::inference::ModelReadyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::inference::ServerMetadataResponse>* AsyncServerMetadataRaw(::grpc::ClientContext* context, const ::inference::ServerMetadataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::inference::ServerMetadataResponse>* PrepareAsyncServerMetadataRaw(::grpc::ClientContext* context, const ::inference::ServerMetadataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::inference::ModelMetadataResponse>* AsyncModelMetadataRaw(::grpc::ClientContext* context, const ::inference::ModelMetadataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::inference::ModelMetadataResponse>* PrepareAsyncModelMetadataRaw(::grpc::ClientContext* context, const ::inference::ModelMetadataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::inference::ModelInferResponse>* AsyncModelInferRaw(::grpc::ClientContext* context, const ::inference::ModelInferRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::inference::ModelInferResponse>* PrepareAsyncModelInferRaw(::grpc::ClientContext* context, const ::inference::ModelInferRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status ServerLive(::grpc::ClientContext* context, const ::inference::ServerLiveRequest& request, ::inference::ServerLiveResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::inference::ServerLiveResponse>> AsyncServerLive(::grpc::ClientContext* context, const ::inference::ServerLiveRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::inference::ServerLiveResponse>>(AsyncServerLiveRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::inference::ServerLiveResponse>> PrepareAsyncServerLive(::grpc::ClientContext* context, const ::inference::ServerLiveRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::inference::ServerLiveResponse>>(PrepareAsyncServerLiveRaw(context, request, cq));
    }
    ::grpc::Status ServerReady(::grpc::ClientContext* context, const ::inference::ServerReadyRequest& request, ::inference::ServerReadyResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::inference::ServerReadyResponse>> AsyncServerReady(::grpc::ClientContext* context, const ::inference::ServerReadyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::inference::ServerReadyResponse>>(AsyncServerReadyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::inference::ServerReadyResponse>> PrepareAsyncServerReady(::grpc::ClientContext* context, const ::inference::ServerReadyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::inference::ServerReadyResponse>>(PrepareAsyncServerReadyRaw(context, request, cq));
    }
    ::grpc::Status ModelReady(::grpc::ClientContext* context, const ::inference::ModelReadyRequest& request, ::inference::ModelReadyResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::inference::ModelReadyResponse>> AsyncModelReady(::grpc::ClientContext* context, const ::inference::ModelReadyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::inference::ModelReadyResponse>>(AsyncModelReadyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::inference::ModelReadyResponse>> PrepareAsyncModelReady(::grpc::ClientContext* context, const ::inference::ModelReadyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::inference::ModelReadyResponse>>(PrepareAsyncModelReadyRaw(context, request, cq));
    }
    ::grpc::Status ServerMetadata(::grpc::ClientContext* context, const ::inference::ServerMetadataRequest& request, ::inference::ServerMetadataResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::inference::ServerMetadataResponse>> AsyncServerMetadata(::grpc::ClientContext* context, const ::inference::ServerMetadataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::inference::ServerMetadataResponse>>(AsyncServerMetadataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::inference::ServerMetadataResponse>> PrepareAsyncServerMetadata(::grpc::ClientContext* context, const ::inference::ServerMetadataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::inference::ServerMetadataResponse>>(PrepareAsyncServerMetadataRaw(context, request, cq));
    }
    ::grpc::Status ModelMetadata(::grpc::ClientContext* context, const ::inference::ModelMetadataRequest& request, ::inference::ModelMetadataResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::inference::ModelMetadataResponse>> AsyncModelMetadata(::grpc::ClientContext* context, const ::inference::ModelMetadataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::inference::ModelMetadataResponse>>(AsyncModelMetadataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::inference::ModelMetadataResponse>> PrepareAsyncModelMetadata(::grpc::ClientContext* context, const ::inference::ModelMetadataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::inference::ModelMetadataResponse>>(PrepareAsyncModelMetadataRaw(context, request, cq));
    }
    ::grpc::Status ModelInfer(::grpc::ClientContext* context, const ::inference::ModelInferRequest& request, ::inference::ModelInferResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::inference::ModelInferResponse>> AsyncModelInfer(::grpc::ClientContext* context, const ::inference::ModelInferRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::inference::ModelInferResponse>>(AsyncModelInferRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::inference::ModelInferResponse>> PrepareAsyncModelInfer(::grpc::ClientContext* context, const ::inference::ModelInferRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::inference::ModelInferResponse>>(PrepareAsyncModelInferRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void ServerLive(::grpc::ClientContext* context, const ::inference::ServerLiveRequest* request, ::inference::ServerLiveResponse* response, std::function<void(::grpc::Status)>) override;
      void ServerLive(::grpc::ClientContext* context, const ::inference::ServerLiveRequest* request, ::inference::ServerLiveResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ServerReady(::grpc::ClientContext* context, const ::inference::ServerReadyRequest* request, ::inference::ServerReadyResponse* response, std::function<void(::grpc::Status)>) override;
      void ServerReady(::grpc::ClientContext* context, const ::inference::ServerReadyRequest* request, ::inference::ServerReadyResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ModelReady(::grpc::ClientContext* context, const ::inference::ModelReadyRequest* request, ::inference::ModelReadyResponse* response, std::function<void(::grpc::Status)>) override;
      void ModelReady(::grpc::ClientContext* context, const ::inference::ModelReadyRequest* request, ::inference::ModelReadyResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ServerMetadata(::grpc::ClientContext* context, const ::inference::ServerMetadataRequest* request, ::inference::ServerMetadataResponse* response, std::function<void(::grpc::Status)>) override;
      void ServerMetadata(::grpc::ClientContext* context, const ::inference::ServerMetadataRequest* request, ::inference::ServerMetadataResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ModelMetadata(::grpc::ClientContext* context, const ::inference::ModelMetadataRequest* request, ::inference::ModelMetadataResponse* response, std::function<void(::grpc::Status)>) override;
      void ModelMetadata(::grpc::ClientContext* context, const ::inference::ModelMetadataRequest* request, ::inference::ModelMetadataResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ModelInfer(::grpc::ClientContext* context, const ::inference::ModelInferRequest* request, ::inference::ModelInferResponse* response, std::function<void(::grpc::Status)>) override;
      void ModelInfer(::grpc::ClientContext* context, const ::inference::ModelInferRequest* request, ::inference::ModelInferResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::inference::ServerLiveResponse>* AsyncServerLiveRaw(::grpc::ClientContext* context, const ::inference::ServerLiveRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::inference::ServerLiveResponse>* PrepareAsyncServerLiveRaw(::grpc::ClientContext* context, const ::inference::ServerLiveRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::inference::ServerReadyResponse>* AsyncServerReadyRaw(::grpc::ClientContext* context, const ::inference::ServerReadyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::inference::ServerReadyResponse>* PrepareAsyncServerReadyRaw(::grpc::ClientContext* context, const ::inference::ServerReadyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::inference::ModelReadyResponse>* AsyncModelReadyRaw(::grpc::ClientContext* context, const ::inference::ModelReadyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::inference::ModelReadyResponse>* PrepareAsyncModelReadyRaw(::grpc::ClientContext* context, const ::inference::ModelReadyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::inference::ServerMetadataResponse>* AsyncServerMetadataRaw(::grpc::ClientContext* context, const ::inference::ServerMetadataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::inference::ServerMetadataResponse>* PrepareAsyncServerMetadataRaw(::grpc::ClientContext* context, const ::inference::ServerMetadataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::inference::ModelMetadataResponse>* AsyncModelMetadataRaw(::grpc::ClientContext* context, const ::inference::ModelMetadataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::inference::ModelMetadataResponse>* PrepareAsyncModelMetadataRaw(::grpc::ClientContext* context, const ::inference::ModelMetadataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::inference::ModelInferResponse>* AsyncModelInferRaw(::grpc::ClientContext* context, const ::inference::ModelInferRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::inference::ModelInferResponse>* PrepareAsyncModelInferRaw(::grpc::ClientContext* context, const ::inference::ModelInferRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_ServerLive_;
    const ::grpc::internal::RpcMethod rpcmethod_ServerReady_;
    const ::grpc::internal::RpcMethod rpcmethod_ModelReady_;
    const ::grpc::internal::RpcMethod rpcmethod_ServerMetadata_;
    const ::grpc::internal::RpcMethod rpcmethod_ModelMetadata_;
    const ::grpc::internal::RpcMethod rpcmethod_ModelInfer_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status ServerLive(::grpc::ServerContext* context, const ::inference::ServerLiveRequest* request, ::inference::ServerLiveResponse* response);
    virtual ::grpc::Status ServerReady(::grpc::ServerContext* context, const ::inference::ServerReadyRequest* request, ::inference::ServerReadyResponse* response);
    virtual ::grpc::Status ModelReady(::grpc::ServerContext* context, const ::inference::ModelReadyRequest* request, ::inference::ModelReadyResponse* response);
    virtual ::grpc::Status ServerMetadata(::grpc::ServerContext* context, const ::inference::ServerMetadataRequest* request, ::inference::ServerMetadataResponse* response);
    virtual ::grpc::Status ModelMetadata(::grpc::ServerContext* context, const ::inference::ModelMetadataRequest* request, ::inference::ModelMetadataResponse* response);
    virtual ::grpc::Status ModelInfer(::grpc::ServerContext* context, const ::inference::ModelInferRequest* request, ::inference::ModelInferResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_ServerLive : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ServerLive() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_ServerLive() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ServerLive(::grpc::ServerContext* /*context*/, const ::inference::ServerLiveRequest* /*request*/, ::inference::ServerLiveResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestServerLive(::grpc::ServerContext* context, ::inference::ServerLiveRequest* request, ::grpc::ServerAsyncResponseWriter< ::inference::ServerLiveResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ServerReady : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ServerReady() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_ServerReady() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ServerReady(::grpc::ServerContext* /*context*/, const ::inference::ServerReadyRequest* /*request*/, ::inference::ServerReadyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestServerReady(::grpc::ServerContext* context, ::inference::ServerReadyRequest* request, ::grpc::ServerAsyncResponseWriter< ::inference::ServerReadyResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ModelReady : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ModelReady() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_ModelReady() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ModelReady(::grpc::ServerContext* /*context*/, const ::inference::ModelReadyRequest* /*request*/, ::inference::ModelReadyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestModelReady(::grpc::ServerContext* context, ::inference::ModelReadyRequest* request, ::grpc::ServerAsyncResponseWriter< ::inference::ModelReadyResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ServerMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ServerMetadata() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_ServerMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ServerMetadata(::grpc::ServerContext* /*context*/, const ::inference::ServerMetadataRequest* /*request*/, ::inference::ServerMetadataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestServerMetadata(::grpc::ServerContext* context, ::inference::ServerMetadataRequest* request, ::grpc::ServerAsyncResponseWriter< ::inference::ServerMetadataResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ModelMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ModelMetadata() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_ModelMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ModelMetadata(::grpc::ServerContext* /*context*/, const ::inference::ModelMetadataRequest* /*request*/, ::inference::ModelMetadataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestModelMetadata(::grpc::ServerContext* context, ::inference::ModelMetadataRequest* request, ::grpc::ServerAsyncResponseWriter< ::inference::ModelMetadataResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ModelInfer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ModelInfer() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_ModelInfer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ModelInfer(::grpc::ServerContext* /*context*/, const ::inference::ModelInferRequest* /*request*/, ::inference::ModelInferResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestModelInfer(::grpc::ServerContext* context, ::inference::ModelInferRequest* request, ::grpc::ServerAsyncResponseWriter< ::inference::ModelInferResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_ServerLive<WithAsyncMethod_ServerReady<WithAsyncMethod_ModelReady<WithAsyncMethod_ServerMetadata<WithAsyncMethod_ModelMetadata<WithAsyncMethod_ModelInfer<Service > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_ServerLive : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ServerLive() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::inference::ServerLiveRequest, ::inference::ServerLiveResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::inference::ServerLiveRequest* request, ::inference::ServerLiveResponse* response) { return this->ServerLive(context, request, response); }));}
    void SetMessageAllocatorFor_ServerLive(
        ::grpc::MessageAllocator< ::inference::ServerLiveRequest, ::inference::ServerLiveResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::inference::ServerLiveRequest, ::inference::ServerLiveResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ServerLive() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ServerLive(::grpc::ServerContext* /*context*/, const ::inference::ServerLiveRequest* /*request*/, ::inference::ServerLiveResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ServerLive(
      ::grpc::CallbackServerContext* /*context*/, const ::inference::ServerLiveRequest* /*request*/, ::inference::ServerLiveResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ServerReady : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ServerReady() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::inference::ServerReadyRequest, ::inference::ServerReadyResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::inference::ServerReadyRequest* request, ::inference::ServerReadyResponse* response) { return this->ServerReady(context, request, response); }));}
    void SetMessageAllocatorFor_ServerReady(
        ::grpc::MessageAllocator< ::inference::ServerReadyRequest, ::inference::ServerReadyResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::inference::ServerReadyRequest, ::inference::ServerReadyResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ServerReady() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ServerReady(::grpc::ServerContext* /*context*/, const ::inference::ServerReadyRequest* /*request*/, ::inference::ServerReadyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ServerReady(
      ::grpc::CallbackServerContext* /*context*/, const ::inference::ServerReadyRequest* /*request*/, ::inference::ServerReadyResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ModelReady : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ModelReady() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::inference::ModelReadyRequest, ::inference::ModelReadyResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::inference::ModelReadyRequest* request, ::inference::ModelReadyResponse* response) { return this->ModelReady(context, request, response); }));}
    void SetMessageAllocatorFor_ModelReady(
        ::grpc::MessageAllocator< ::inference::ModelReadyRequest, ::inference::ModelReadyResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::inference::ModelReadyRequest, ::inference::ModelReadyResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ModelReady() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ModelReady(::grpc::ServerContext* /*context*/, const ::inference::ModelReadyRequest* /*request*/, ::inference::ModelReadyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ModelReady(
      ::grpc::CallbackServerContext* /*context*/, const ::inference::ModelReadyRequest* /*request*/, ::inference::ModelReadyResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ServerMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ServerMetadata() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::inference::ServerMetadataRequest, ::inference::ServerMetadataResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::inference::ServerMetadataRequest* request, ::inference::ServerMetadataResponse* response) { return this->ServerMetadata(context, request, response); }));}
    void SetMessageAllocatorFor_ServerMetadata(
        ::grpc::MessageAllocator< ::inference::ServerMetadataRequest, ::inference::ServerMetadataResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::inference::ServerMetadataRequest, ::inference::ServerMetadataResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ServerMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ServerMetadata(::grpc::ServerContext* /*context*/, const ::inference::ServerMetadataRequest* /*request*/, ::inference::ServerMetadataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ServerMetadata(
      ::grpc::CallbackServerContext* /*context*/, const ::inference::ServerMetadataRequest* /*request*/, ::inference::ServerMetadataResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ModelMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ModelMetadata() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::inference::ModelMetadataRequest, ::inference::ModelMetadataResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::inference::ModelMetadataRequest* request, ::inference::ModelMetadataResponse* response) { return this->ModelMetadata(context, request, response); }));}
    void SetMessageAllocatorFor_ModelMetadata(
        ::grpc::MessageAllocator< ::inference::ModelMetadataRequest, ::inference::ModelMetadataResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::inference::ModelMetadataRequest, ::inference::ModelMetadataResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ModelMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ModelMetadata(::grpc::ServerContext* /*context*/, const ::inference::ModelMetadataRequest* /*request*/, ::inference::ModelMetadataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ModelMetadata(
      ::grpc::CallbackServerContext* /*context*/, const ::inference::ModelMetadataRequest* /*request*/, ::inference::ModelMetadataResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ModelInfer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ModelInfer() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::inference::ModelInferRequest, ::inference::ModelInferResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::inference::ModelInferRequest* request, ::inference::ModelInferResponse* response) { return this->ModelInfer(context, request, response); }));}
    void SetMessageAllocatorFor_ModelInfer(
        ::grpc::MessageAllocator< ::inference::ModelInferRequest, ::inference::ModelInferResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::inference::ModelInferRequest, ::inference::ModelInferResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ModelInfer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ModelInfer(::grpc::ServerContext* /*context*/, const ::inference::ModelInferRequest* /*request*/, ::inference::ModelInferResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ModelInfer(
      ::grpc::CallbackServerContext* /*context*/, const ::inference::ModelInferRequest* /*request*/, ::inference::ModelInferResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_ServerLive<WithCallbackMethod_ServerReady<WithCallbackMethod_ModelReady<WithCallbackMethod_ServerMetadata<WithCallbackMethod_ModelMetadata<WithCallbackMethod_ModelInfer<Service > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_ServerLive : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ServerLive() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_ServerLive() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ServerLive(::grpc::ServerContext* /*context*/, const ::inference::ServerLiveRequest* /*request*/, ::inference::ServerLiveResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ServerReady : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ServerReady() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_ServerReady() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ServerReady(::grpc::ServerContext* /*context*/, const ::inference::ServerReadyRequest* /*request*/, ::inference::ServerReadyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ModelReady : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ModelReady() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_ModelReady() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ModelReady(::grpc::ServerContext* /*context*/, const ::inference::ModelReadyRequest* /*request*/, ::inference::ModelReadyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ServerMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ServerMetadata() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_ServerMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ServerMetadata(::grpc::ServerContext* /*context*/, const ::inference::ServerMetadataRequest* /*request*/, ::inference::ServerMetadataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ModelMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ModelMetadata() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_ModelMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ModelMetadata(::grpc::ServerContext* /*context*/, const ::inference::ModelMetadataRequest* /*request*/, ::inference::ModelMetadataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ModelInfer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ModelInfer() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_ModelInfer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ModelInfer(::grpc::ServerContext* /*context*/, const ::inference::ModelInferRequest* /*request*/, ::inference::ModelInferResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_ServerLive : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ServerLive() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_ServerLive() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ServerLive(::grpc::ServerContext* /*context*/, const ::inference::ServerLiveRequest* /*request*/, ::inference::ServerLiveResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestServerLive(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ServerReady : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ServerReady() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_ServerReady() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ServerReady(::grpc::ServerContext* /*context*/, const ::inference::ServerReadyRequest* /*request*/, ::inference::ServerReadyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestServerReady(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ModelReady : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ModelReady() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_ModelReady() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ModelReady(::grpc::ServerContext* /*context*/, const ::inference::ModelReadyRequest* /*request*/, ::inference::ModelReadyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestModelReady(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ServerMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ServerMetadata() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_ServerMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ServerMetadata(::grpc::ServerContext* /*context*/, const ::inference::ServerMetadataRequest* /*request*/, ::inference::ServerMetadataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestServerMetadata(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ModelMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ModelMetadata() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_ModelMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ModelMetadata(::grpc::ServerContext* /*context*/, const ::inference::ModelMetadataRequest* /*request*/, ::inference::ModelMetadataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestModelMetadata(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ModelInfer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ModelInfer() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_ModelInfer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ModelInfer(::grpc::ServerContext* /*context*/, const ::inference::ModelInferRequest* /*request*/, ::inference::ModelInferResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestModelInfer(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ServerLive : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ServerLive() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ServerLive(context, request, response); }));
    }
    ~WithRawCallbackMethod_ServerLive() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ServerLive(::grpc::ServerContext* /*context*/, const ::inference::ServerLiveRequest* /*request*/, ::inference::ServerLiveResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ServerLive(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ServerReady : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ServerReady() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ServerReady(context, request, response); }));
    }
    ~WithRawCallbackMethod_ServerReady() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ServerReady(::grpc::ServerContext* /*context*/, const ::inference::ServerReadyRequest* /*request*/, ::inference::ServerReadyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ServerReady(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ModelReady : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ModelReady() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ModelReady(context, request, response); }));
    }
    ~WithRawCallbackMethod_ModelReady() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ModelReady(::grpc::ServerContext* /*context*/, const ::inference::ModelReadyRequest* /*request*/, ::inference::ModelReadyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ModelReady(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ServerMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ServerMetadata() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ServerMetadata(context, request, response); }));
    }
    ~WithRawCallbackMethod_ServerMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ServerMetadata(::grpc::ServerContext* /*context*/, const ::inference::ServerMetadataRequest* /*request*/, ::inference::ServerMetadataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ServerMetadata(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ModelMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ModelMetadata() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ModelMetadata(context, request, response); }));
    }
    ~WithRawCallbackMethod_ModelMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ModelMetadata(::grpc::ServerContext* /*context*/, const ::inference::ModelMetadataRequest* /*request*/, ::inference::ModelMetadataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ModelMetadata(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ModelInfer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ModelInfer() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ModelInfer(context, request, response); }));
    }
    ~WithRawCallbackMethod_ModelInfer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ModelInfer(::grpc::ServerContext* /*context*/, const ::inference::ModelInferRequest* /*request*/, ::inference::ModelInferResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ModelInfer(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ServerLive : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ServerLive() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::inference::ServerLiveRequest, ::inference::ServerLiveResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::inference::ServerLiveRequest, ::inference::ServerLiveResponse>* streamer) {
                       return this->StreamedServerLive(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ServerLive() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ServerLive(::grpc::ServerContext* /*context*/, const ::inference::ServerLiveRequest* /*request*/, ::inference::ServerLiveResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedServerLive(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::inference::ServerLiveRequest,::inference::ServerLiveResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ServerReady : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ServerReady() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::inference::ServerReadyRequest, ::inference::ServerReadyResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::inference::ServerReadyRequest, ::inference::ServerReadyResponse>* streamer) {
                       return this->StreamedServerReady(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ServerReady() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ServerReady(::grpc::ServerContext* /*context*/, const ::inference::ServerReadyRequest* /*request*/, ::inference::ServerReadyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedServerReady(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::inference::ServerReadyRequest,::inference::ServerReadyResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ModelReady : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ModelReady() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::inference::ModelReadyRequest, ::inference::ModelReadyResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::inference::ModelReadyRequest, ::inference::ModelReadyResponse>* streamer) {
                       return this->StreamedModelReady(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ModelReady() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ModelReady(::grpc::ServerContext* /*context*/, const ::inference::ModelReadyRequest* /*request*/, ::inference::ModelReadyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedModelReady(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::inference::ModelReadyRequest,::inference::ModelReadyResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ServerMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ServerMetadata() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::inference::ServerMetadataRequest, ::inference::ServerMetadataResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::inference::ServerMetadataRequest, ::inference::ServerMetadataResponse>* streamer) {
                       return this->StreamedServerMetadata(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ServerMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ServerMetadata(::grpc::ServerContext* /*context*/, const ::inference::ServerMetadataRequest* /*request*/, ::inference::ServerMetadataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedServerMetadata(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::inference::ServerMetadataRequest,::inference::ServerMetadataResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ModelMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ModelMetadata() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::inference::ModelMetadataRequest, ::inference::ModelMetadataResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::inference::ModelMetadataRequest, ::inference::ModelMetadataResponse>* streamer) {
                       return this->StreamedModelMetadata(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ModelMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ModelMetadata(::grpc::ServerContext* /*context*/, const ::inference::ModelMetadataRequest* /*request*/, ::inference::ModelMetadataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedModelMetadata(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::inference::ModelMetadataRequest,::inference::ModelMetadataResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ModelInfer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ModelInfer() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::inference::ModelInferRequest, ::inference::ModelInferResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::inference::ModelInferRequest, ::inference::ModelInferResponse>* streamer) {
                       return this->StreamedModelInfer(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ModelInfer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ModelInfer(::grpc::ServerContext* /*context*/, const ::inference::ModelInferRequest* /*request*/, ::inference::ModelInferResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedModelInfer(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::inference::ModelInferRequest,::inference::ModelInferResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_ServerLive<WithStreamedUnaryMethod_ServerReady<WithStreamedUnaryMethod_ModelReady<WithStreamedUnaryMethod_ServerMetadata<WithStreamedUnaryMethod_ModelMetadata<WithStreamedUnaryMethod_ModelInfer<Service > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_ServerLive<WithStreamedUnaryMethod_ServerReady<WithStreamedUnaryMethod_ModelReady<WithStreamedUnaryMethod_ServerMetadata<WithStreamedUnaryMethod_ModelMetadata<WithStreamedUnaryMethod_ModelInfer<Service > > > > > > StreamedService;
};

}  // namespace inference


#endif  // GRPC_grpc_5fpredict_5fv2_2eproto__INCLUDED
